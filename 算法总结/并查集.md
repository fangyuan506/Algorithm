# 并查集

## 并查集介绍

并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。并查集的重要思想在于，用集合中的一个元素代表集合。

并查集支持两种操作：

- 合并（Union）：把两个不相交的集合合并为一个集合。
- 查询（Find）：查询两个元素是否在同一个集合中。



## 初始化

初始时，每个元素都位于一个单独的集合，表示为一棵只有根节点的树。

``` java
for (int i = 0; i < n; i++) {
    p[i] = i;
}
```



## 查询

查询时，我们需要沿着树向上移动，直至找到根节点。

``` java
private int find(int x) {
    return p[x] == x ? x : find(p[x]);
}
```



## 合并

要合并两棵树，我们只需要将一棵树的根节点连到另一棵树的根节点。

``` java
private void union(int x, int y) {
    p[find(y)] = find(x);
}
```



## 路径压缩

查询过程中经过的每个元素都属于该集合，我们可以将其直接连到根节点以加快后续查询。

``` java
private int find(int x) {
    return p[x] == x ? x : (p[x] = find(p[x]));
}
```



## 启发式合并

合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。所以我们在合并时将节点较少或高度较小的树连到另一棵，以免发生退化。由于节点数与高度这两个特征都很容易维护，我们常常从中择一，作为估价函数。

这里注意，只能在基于节点数的并查集上采用这种路径压缩，而不能在基于高度的并查集上采用这种路径压缩。因为路径压缩后根的节点数不变，但高度会变，虽然可以在路径压缩的时候，重新计算高度，但这样代码麻烦了很多，同时收益又很小。

其实我们在优化并查集查询效率的时候，只用路径压缩的思路就够了，不仅代码实现精简，而且效率足够高。

``` java
// 基于节点数
public void union(int x, int y) {
    int rx = find(x);
    int ry = find(y);
    if (rx == ry) return;
    if (h[rx] <= h[ry]) {
        p[rx] = ry;
        h[ry] += h[rx];
    } else {
        p[ry] = rx;
        h[rx] += h[ry];
    }
}

// 基于高度
public void union(int x, int y) {
    int rx = find(x);
    int ry = find(y);
    if (h[rx] <= h[ry]) {
        p[rx] = ry;
    } else {
        p[ry] = rx;
    }
    if (h[rx] == h[ry] && rx != ry) h[ry]++;
}
```

